#version 450 core
layout(local_size_x = 128) in;

struct Particle {
    vec4 position;
    vec4 velocity;
    vec4 color;
};

layout(std430, binding = 0) buffer ParticleSSBO {
    Particle particles[];
};

uniform float dt;
uniform int pCount;
uniform float time;
uniform vec3 gravity;
uniform float speed;
uniform float lifeTime;

// 互動參數
uniform vec3 attractorPos;
uniform float attractorStrength;
uniform float bounce;

float rand(vec2 co){ return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453); }

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= pCount) return;

    Particle p = particles[id];

    // 1. 互動場計算 (Interaction Force)
    // 增加一點互動半徑的變數，這裡設為 20.0
    float interactionRadius = 20.0;
    float distToMouse = 0.0; // 稍後顏色計算要用

    if (attractorStrength != 0.0) {
        vec3 dir = attractorPos - p.position.xyz;
        distToMouse = length(dir);
        
        if (distToMouse > 0.1 && distToMouse < interactionRadius) { 
            // 距離越近力量越強，但也加個上限避免噴飛
            vec3 force = normalize(dir) * attractorStrength * (1.0 / max(distToMouse, 1.0)); 
            p.velocity.xyz += force * dt;
        }
    }

    // 2. 基本物理
    p.velocity.xyz += gravity * dt;
    p.position.xyz += p.velocity.xyz * dt;

    // 3. 地面碰撞
    float floorY = -8.0;
    if (p.position.y < floorY) {
        p.position.y = floorY + 0.01;
        p.velocity.y *= -bounce;
        p.velocity.x *= 0.8;
        p.velocity.z *= 0.8;
    }

    // 4. 顏色更新 (關鍵修改區域)
    // -----------------------------------------------------------
    
    // A. 基礎顏色 (根據速度：暗藍 -> 亮橘)
    float speedFactor = length(p.velocity.xyz) * 0.05;
    vec3 baseColor = mix(vec3(0.1, 0.1, 0.5), vec3(1.0, 0.3, 0.1), speedFactor);
    
    // B. 地面碰撞變白
    if (p.position.y < floorY + 0.5) {
         baseColor = vec3(1.0);
    } 
    // C. 互動變色 (藍色/紅色)
    else if (attractorStrength != 0.0 && distToMouse < interactionRadius) {
        // 計算混合比例：越靠近滑鼠越顯色
        float mixRatio = 1.0 - (distToMouse / interactionRadius);
        mixRatio = pow(mixRatio, 2.0); // 讓中心更亮

        vec3 interactionColor;
        if (attractorStrength > 0.0) {
            interactionColor = vec3(0.2, 0.8, 1.0); // 吸引：亮藍色 (Cyan)
        } else {
            interactionColor = vec3(1.0, 0.1, 0.2); // 排斥：紅色
        }
        
        // 將基礎顏色與互動顏色混合
        baseColor = mix(baseColor, interactionColor, mixRatio);
    }

    p.color = vec4(baseColor, 1.0);
    // -----------------------------------------------------------

    // 5. 重生邏輯
    if (p.position.y < lifeTime) { 
        p.position.xyz = vec3(0.0, 0.0, 0.0);
        float r1 = rand(vec2(id, time));
        float r2 = rand(vec2(id + 100, time));
        float r3 = rand(vec2(id + 200, time));
        p.velocity.x = (r1 - 0.5) * 5.0;
        p.velocity.y = speed + r2 * 5.0;
        p.velocity.z = (r3 - 0.5) * 5.0;
    }

    particles[id] = p;
}